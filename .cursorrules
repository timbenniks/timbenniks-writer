# Tim Benniks Writer - Cursor Rules

## Project Overview
A comprehensive content management and writing platform built with Next.js 16 and React 19. The application provides a distraction-free writing experience for creating articles and managing videos with full GitHub integration, Contentstack export capabilities, AI-powered features, and more.

## Tech Stack

### Core Framework
- **Next.js 16.0.10** - React framework with App Router
- **React 19.2.1** - UI library
- **TypeScript 5.9.3** - Type safety

### Rich Text Editor
- **TipTap 2.27.1** - Headless rich text editor framework
  - `@tiptap/react` - React integration
  - `@tiptap/starter-kit` - Basic formatting (bold, italic, headings, lists, blockquote)
  - `@tiptap/extension-link` - Link support
  - `@tiptap/extension-placeholder` - Placeholder text
  - `@tiptap/extension-underline` - Underline formatting
  - `@tiptap/extension-image` - Image insertion via URL
  - `@tiptap/extension-code-block-lowlight` - Code blocks with syntax highlighting

### Syntax Highlighting
- **lowlight 3.3.0** - Code syntax highlighting (uses highlight.js)
- Supported languages: JavaScript, TypeScript, CSS, HTML, JSON, Python, Bash, SQL

### Markdown & Content Processing
- **turndown 7.2.2** - HTML to Markdown conversion
- **gray-matter 4.0.3** - YAML frontmatter parsing
- **js-yaml 4.1.1** - YAML parsing and formatting
- **remark** - Markdown processing
  - `remark-parse` - Markdown parsing
  - `remark-rehype` - Markdown to HTML AST
  - `rehype-stringify` - HTML AST to string
- **react-markdown 10.1.0** - React markdown renderer
- **rehype-highlight 7.0.2** - Syntax highlighting for markdown

### Integrations
- **@octokit/rest 22.0.1** - GitHub REST API client
- **openai 6.10.0** - OpenAI API client
- **@google/generative-ai 0.24.1** - Google Gemini AI
- **googleapis 167.0.0** - Google APIs (YouTube, Docs)
- **cloudinary 2.8.0** - Cloudinary image management
- **youtubei.js 16.0.1** - YouTube API client
- **diff 8.0.2** - Text diff generation

### Styling
- **Tailwind CSS 3.4.18** - Utility-first CSS framework
- **Google Fonts** - JetBrains Mono for code blocks (via Next.js font optimization)

### Utilities
- **clsx 2.1.1** - Conditional class names
- **cheerio 1.1.2** - HTML parsing and manipulation

## Project Structure

```
/app
  /api
    /articles          # Articles API endpoints (GET, POST, [slug])
    /videos            # Videos API endpoints (GET, POST, [slug])
    /github            # GitHub integration endpoints
      /check           # Check file SHA for conflicts
      /connect         # Test GitHub connection
      /delete          # Delete files
      /files           # List markdown files
      /load            # Load file content
      /save            # Save/update files
      /history         # Get commit history
      /revert          # Revert to previous version
      /videos          # Video-specific GitHub operations
    /contentstack      # Contentstack export endpoints
      /assets          # Upload images
      /entries         # Create/update entries
      /taxonomies      # Manage taxonomies
      /videos          # Video export endpoints
    /openai            # OpenAI integration
      /chat            # Chat completion
      /stream          # Streaming responses
      /generate-metadata # Generate article metadata
      /generate-video-tags # Generate video tags
    /youtube           # YouTube integration
      /playlist-videos # Get playlist videos
      /transcript      # Get video transcript
    /google            # Google Docs export
    /cloudinary        # Cloudinary image upload
    /gemini            # Gemini AI image generation
  /article             # Article editor page
  /video               # Video editor page
  /videos              # Videos list page
  /settings            # Settings page
  /components          # React components
    /ui                # Reusable UI components (Modal, DeleteConfirmModal, ProgressBar)
  /hooks               # Custom React hooks
    - useGitHubConfig.ts
    - useGitHubFiles.ts
    - useGitHubVideos.ts
    - usePlaylists.ts
    - useCloudinaryWidget.ts
  /types               # TypeScript type definitions
    - github.ts
    - video.ts
  /utils               # Utility functions (DRY architecture)
    - githubConfig.ts  # GitHub configuration parsing
    - apiHelpers.ts    # API parameter parsing and response formatting
    - fileFetcher.ts   # File fetching and batch processing
    - cache.ts         # Caching utilities with purge support
    - articleTransform.ts # Article transformation utilities
    - videoTransform.ts  # Video transformation utilities
    - markdown.ts      # Markdown/frontmatter utilities
    - contentstackRte.ts # Contentstack RTE conversion
    - helpers.ts       # General helper functions
    - constants.ts     # Constants and configuration
    - streamingHelpers.ts # Streaming response helpers
    - toneInstructions.ts # AI tone instructions
```

## Architecture Principles

### DRY (Don't Repeat Yourself)
The codebase follows DRY principles with shared utilities:

1. **GitHub Configuration** (`app/utils/githubConfig.ts`)
   - Centralized GitHub config parsing
   - Environment variable handling
   - Config validation
   - Used by: Articles API, Videos API, GitHub routes

2. **API Helpers** (`app/utils/apiHelpers.ts`)
   - Query parameter parsing (pagination, sorting, filtering)
   - Cache purge detection
   - Error response formatting
   - Success response formatting with cache headers
   - Used by: All API routes

3. **File Fetcher** (`app/utils/fileFetcher.ts`)
   - Batch file processing (20 files at a time)
   - Optimized fetching (download_url preferred)
   - Markdown file filtering
   - Frontmatter parsing
   - Used by: Articles API, Videos API

4. **Cache Utilities** (`app/utils/cache.ts`)
   - Multi-level caching (file listings, processed content, individual files)
   - Cache tag management
   - Cache purge functions
   - Used by: Articles API, Videos API, Save routes

5. **Transformation Utilities**
   - `articleTransform.ts` - Article to Contentstack format
   - `videoTransform.ts` - Video to Contentstack format
   - Shared filtering, sorting, pagination logic

## Key Features

### Editor Features
1. **Text Formatting**
   - Style dropdown: Normal (p), Heading (h2), Subheading (h3)
   - Bold, Italic, Underline
   - Unordered lists, Ordered lists
   - Blockquote
   - Code blocks with syntax highlighting and language selection
   - Links with URL input
   - Images with URL input and alt text support

2. **Code Block Features**
   - Syntax highlighting via lowlight
   - Language selection dropdown
   - Code formatting utility (normalizes indentation, removes trailing whitespace)
   - Auto-formatting on paste
   - JetBrains Mono font for improved readability

3. **Article Metadata**
   - Cover image (hero image) with 16:9 aspect ratio enforcement
   - Title field (synced with metadata panel)
   - Metadata panel sidebar with:
     - Slug, Title, Description, Date
     - Canonical URL, Reading Time
     - Tags (add/remove)
     - FAQs (question/answer pairs)
     - Hero Image URL with preview
     - Draft status checkbox

4. **Markdown Export**
   - View markdown preview modal
   - Copy markdown to clipboard
   - Preserves code block languages
   - Converts all editor content to markdown format

### Video Management Features
1. **Video Editor**
   - Edit video metadata (title, description, date, position, tags, playlist)
   - Edit video transcript
   - YouTube video embedding
   - Save to GitHub

2. **Video Import**
   - Import videos from YouTube playlists
   - Batch import with progress tracking
   - Automatic frontmatter generation

3. **Bulk Operations**
   - Bulk tag generation with AI
   - Bulk export to Contentstack
   - Video selection and filtering

### GitHub Integration Features
1. **Repository Management**
   - Connect to GitHub repositories via Personal Access Token
   - Configure repository, branch, and subfolder path
   - Settings page at `/settings` for configuration
   - Configuration stored in localStorage

2. **File Operations**
   - List markdown files from GitHub repository
   - Load files with frontmatter parsing
   - Create new articles/videos
   - Save/update articles/videos with commit messages
   - Delete articles/videos from GitHub
   - Conflict detection (checks file SHA before saving)

3. **Frontmatter Handling**
   - Preserves original frontmatter structure and formatting
   - Maintains key order and naming conventions (snake_case vs camelCase)
   - Updates `head.meta` section (twitter:image, twitter:title, twitter:description, keywords)
   - Preserves tags format (flow vs block style)
   - Date handling: Always appends `T10:00:00Z` to date-only values to prevent diffs
   - Preserves existing fields (id, collection_id, etc.)

4. **Article List Page** (`/`)
   - Grid view of articles with hero images
   - Search functionality
   - Tag filtering (sidebar)
   - Date sorting (newest/oldest)
   - Draft badge display
   - Delete button on hover
   - Click to edit articles

5. **Save Workflow**
   - Diff view before committing
   - Commit message input
   - Conflict detection and warnings
   - Status indicators (saving, saved, error)
   - Last saved timestamp
   - Keyboard shortcut (Cmd/Ctrl+S)
   - Automatic cache invalidation on save

6. **History/Versioning**
   - View commit history for files
   - View content of previous commits
   - Revert to previous versions
   - Accessible via history button in header
   - Side panel with commit list and details

7. **Auto-Slug Generation**
   - Automatically generates slug from title for new articles
   - Only applies to new articles, not existing ones
   - Live updates in metadata panel
   - Can be manually overridden

### API Features

#### Articles API (`/api/articles`)
- **GET** - List articles with filtering, pagination, sorting
  - Query params: `limit`, `offset`, `order`, `orderBy`, `tags`, `draft`, `purge`
- **POST** - Same as GET but with body (allows config overrides)
- **GET /api/articles/[slug]** - Get single article by slug/videoId/path
- Returns Contentstack JSON format
- Cached for 7 days (configurable via `?purge=true`)

#### Videos API (`/api/videos`)
- **GET** - List videos with filtering, pagination, sorting
  - Query params: `limit`, `offset`, `order`, `orderBy`, `tags`, `playlist`, `purge`
- **POST** - Same as GET but with body (allows config overrides)
- **GET /api/videos/[slug]** - Get single video by videoId/path
- Returns Contentstack JSON format
- Cached for 7 days (configurable via `?purge=true`)

### Contentstack Integration Features
1. **Article Export**
   - Export articles to Contentstack with full metadata
   - Automatic taxonomy mapping
   - Image upload to Contentstack assets
   - JSON RTE conversion

2. **Video Export**
   - Export videos to Contentstack
   - Playlist to category mapping
   - Taxonomy management

3. **Bulk Export**
   - Export multiple articles/videos at once
   - Rate-limited batch processing
   - Progress tracking
   - Detailed success/error reports

### AI Features
1. **OpenAI Integration**
   - Chat completion
   - Streaming responses
   - Metadata generation
   - Video tag generation
   - Writing assistance

2. **Gemini AI**
   - Image generation prompts
   - Image generation

### Caching Strategy
- **File listings**: Cached for 24 hours
- **Processed content**: Cached for 7 days
- **Individual files**: Cached for 7 days
- **Cache purging**: 
  - URL-based: `?purge=true` or `?purge=articles`/`?purge=videos`
  - Automatic: Cache purged on save operations
- **HTTP caching**: Client-side caching with `Cache-Control` headers

## Coding Conventions

### TypeScript
- Use strict TypeScript (`strict: true` in tsconfig.json)
- Prefer type imports: `import type { ... }`
- Use interfaces for component props
- Export types/interfaces when used across components
- Avoid `any` types unless absolutely necessary

### React Patterns
- Use functional components with hooks
- Client components must have `"use client"` directive
- Use `useState` for local component state
- Use `useEffect` for side effects and prop synchronization
- Prefer controlled components for inputs
- Use `useRouter` and `useSearchParams` from `next/navigation` for routing
- Wrap `useSearchParams` in Suspense boundaries

### Component Structure
```typescript
// Component imports
"use client";

import { useState, useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import clsx from "clsx";
// ... other imports

// Type definitions
interface ComponentProps {
  // props
}

// Component
export default function Component({ ... }: ComponentProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  // State
  // Effects
  // Handlers
  // Render
}
```

### Styling Guidelines
- Use Tailwind CSS utility classes
- Use `clsx` for conditional classes
- Follow Tailwind's spacing scale (p-2, p-4, gap-2, etc.)
- Use semantic color names: `gray-900`, `gray-700`, `gray-100`
- Active states: `bg-gray-900 text-white`
- Hover states: `hover:bg-gray-100`
- Disabled states: `text-gray-300 cursor-not-allowed`
- Modal overlays: `fixed inset-0 bg-black/20 z-40`
- Modal content: `fixed inset-0 z-50 flex items-center justify-center`

### API Route Patterns
- Use shared utilities from `app/utils/`:
  - `getGitHubConfig()` - GitHub config parsing
  - `parsePaginationParams()` - Pagination parsing
  - `parseSortParams()` - Sort parsing
  - `parseTags()` - Tags parsing
  - `shouldPurgeCache()` - Cache purge detection
  - `createSuccessResponse()` - Success response with cache headers
  - `handleApiError()` - Error response formatting
- Return consistent response format: `{ success: boolean, error?: string, ... }`
- Handle errors gracefully (404, 409 conflicts, 403 permissions)
- Use caching where appropriate
- Add cache purge support via query parameter

### GitHub API Patterns
- All GitHub API routes are in `/app/api/github/`
- Use POST requests for all operations
- Validate required fields using `validateGitHubFields()` from `app/api/github/utils.ts`
- Use `parseRepo()` from `app/api/github/utils.ts` for repo parsing
- Handle errors gracefully (404, 409 conflicts, 403 permissions)
- Return consistent response format: `{ success: boolean, error?: string, ... }`
- Use Octokit for GitHub API calls
- Include SHA for optimistic locking on updates/deletes
- Purge cache after save operations

### Frontmatter Handling
- Use `gray-matter` to parse frontmatter from markdown files
- Use `js-yaml` to dump frontmatter with specific options:
  - `lineWidth: -1` - No line wrapping
  - `noRefs: true` - No YAML references
  - `sortKeys: false` - Preserve key order
  - `indent: 2` - 2-space indentation
  - `flowLevel: -1` - Block style for root object
- Preserve original key names (snake_case vs camelCase)
- Preserve original date format (with time component)
- Always append `T10:00:00Z` to date-only values
- Preserve tags array format (flow vs block style)
- Update `head.meta` section based on metadata fields

### Date Handling
- Dates in frontmatter should always include time component: `T10:00:00Z`
- When loading: Extract date part (YYYY-MM-DD) for form input
- When saving: Append `T10:00:00Z` if date is date-only
- Preserve original time component if it exists
- This prevents unnecessary diffs when editing articles

### Slug Generation
- Use `slugify` function to convert titles to URL-friendly slugs
- Only auto-generate for new articles (`isNewFile === true`)
- Track auto-generated slugs to allow manual overrides
- Live update slug field when title changes (for new articles only)

### Caching Patterns
- Use `getCachedProcessedData()` for processed content (articles/videos)
- Use `getCachedFileListing()` for GitHub file listings
- Use `getCachedFileContent()` for individual files
- Create cache keys using utility functions:
  - `createArticlesCacheKey()`
  - `createVideosCacheKey()`
  - `createRepoCacheKey()`
  - `createFileCacheKey()`
- Purge cache using:
  - `purgeArticlesCache()` - After article save
  - `purgeVideosCache()` - After video save
  - `purgeAllCache()` - Purge everything

### File Fetching Patterns
- Use `processFilesInBatches()` for batch processing (20 files at a time)
- Use `fetchFileContent()` for optimized file fetching (download_url preferred)
- Use `filterMarkdownFiles()` to filter markdown files
- Use `parseFrontmatter()` to parse frontmatter

## Important Notes

### Editor Configuration
- Disable default `codeBlock` in StarterKit (use CodeBlockLowlight instead)
- Configure Image extension with `inline: true` and `allowBase64: false`
- Configure Link extension with `openOnClick: false`
- Use Placeholder extension for empty state

### State Management
- Article metadata is managed in Editor component
- Title and hero image sync bidirectionally between editor and metadata panel
- Use `useEffect` to sync local state when props change
- GitHub config stored in localStorage
- Listen to storage events for config updates

### Aspect Ratios
- Hero image always maintains 16:9 aspect ratio (`aspect-video`)
- Use `object-cover` with `object-position: top center` for article cards
- Use `absolute inset-0` positioning for images in cards

### Font Configuration
- JetBrains Mono loaded via Next.js font optimization
- Applied to code blocks via CSS (`font-family: 'JetBrains Mono', ...`)
- Font variable: `--font-jetbrains-mono`

### Code Formatting
- Custom `formatCode` function normalizes indentation
- Detects tabs vs spaces
- Removes trailing whitespace
- Removes trailing empty lines
- Available via toolbar button and auto-format on paste

### Route Structure
- `/` - Home page (articles list)
- `/article` - Article editor page
- `/video` - Video editor page
- `/videos` - Videos list page
- `/settings` - GitHub settings page
- `/api/articles` - Articles API
- `/api/videos` - Videos API
- `/api/github/*` - GitHub API routes

### File Operations
- New articles: Navigate to `/article?new=true`
- Edit articles: Navigate to `/article?file=<path>`
- After saving new article: Reload from GitHub and redirect
- Delete articles: Confirmation modal, then remove from GitHub and list

### Conflict Detection
- Check file SHA before saving
- Show warning if file changed remotely
- Use SHA for optimistic locking
- Periodic status checks for remote changes

## Best Practices

1. **Always use TypeScript** - No `any` types unless absolutely necessary
2. **Use shared utilities** - Don't duplicate code, use utilities from `app/utils/`
3. **Client Components** - Mark components with `"use client"` when using hooks or browser APIs
4. **Accessibility** - Include `aria-label` and `title` attributes on buttons
5. **Error Handling** - Handle errors gracefully, show user-friendly error messages
6. **Performance** - Use Next.js font optimization for custom fonts
7. **Code Quality** - Run `npm run build` before committing to catch TypeScript errors
8. **Consistency** - Follow existing patterns for similar features
9. **UX** - Provide visual feedback for all interactions (hover, active, disabled states)
10. **Confirmation Dialogs** - Use modals for destructive actions (delete, etc.)
11. **Loading States** - Show loading indicators for async operations
12. **Error States** - Display clear error messages to users
13. **Frontmatter Preservation** - Always preserve original frontmatter structure and formatting
14. **Caching** - Use caching for expensive operations, purge on updates
15. **DRY** - Don't repeat code, extract to shared utilities

## Common Patterns

### API Route with Caching
```typescript
import { NextRequest } from "next/server";
import { getGitHubConfig, isConfigError } from "../../utils/githubConfig";
import { parsePaginationParams, parseSortParams, parseTags, shouldPurgeCache, createSuccessResponse, handleApiError } from "../../utils/apiHelpers";
import { purgeArticlesCache } from "../../utils/cache";

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;

    // Handle cache purge
    if (shouldPurgeCache(searchParams, "articles")) {
      await purgeArticlesCache();
    }

    // Parse parameters
    const { limit, offset } = parsePaginationParams(searchParams);
    const { order, orderBy } = parseSortParams(searchParams, "date");
    const tags = parseTags(searchParams);

    // Get GitHub config
    const config = getGitHubConfig();
    if (isConfigError(config)) {
      return handleApiError({ status: 500, message: config.error }, "Configuration error", {
        articles: [],
        total: 0,
        limit,
        offset,
      });
    }

    // ... fetch and process data ...

    return createSuccessResponse({ articles, total, limit, offset });
  } catch (error: any) {
    return handleApiError(error, "Failed to fetch articles", {
      articles: [],
      total: 0,
      limit: 10,
      offset: 0,
    });
  }
}
```

### Button with Active State
```typescript
<button
  onClick={() => editor.chain().focus().toggleBold().run()}
  className={clsx(
    "p-2 rounded-md transition-colors",
    editor.isActive("bold")
      ? "bg-gray-900 text-white"
      : "text-gray-700 hover:bg-gray-100"
  )}
  title="Bold"
>
  <BoldIcon />
</button>
```

### Modal/Overlay Pattern
```typescript
{isOpen && (
  <>
    <div
      className="fixed inset-0 bg-black/20 z-40"
      onClick={onClose}
    />
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* Modal content */}
    </div>
  </>
)}
```

### Syncing State with Props
```typescript
useEffect(() => {
  setLocalState(propValue);
}, [propValue]);
```

### Loading localStorage Config
```typescript
useEffect(() => {
  const loadConfig = () => {
    const saved = localStorage.getItem("githubConfig");
    if (saved) {
      try {
        const parsed = JSON.parse(saved);
        setGitHubConfig(parsed);
      } catch (e) {
        console.error("Failed to parse config:", e);
      }
    }
  };
  
  loadConfig();
  window.addEventListener("storage", loadConfig);
  return () => window.removeEventListener("storage", loadConfig);
}, []);
```

## Development Workflow

### Running the Project
```bash
npm run dev      # Development server
npm run build    # Production build
npm run start    # Start production server
npm run lint     # Run ESLint
```

### Adding New Features
1. Follow existing component patterns
2. Use TypeScript interfaces for props
3. Maintain consistent styling with Tailwind
4. Use shared utilities where possible
5. Test with Next.js build (`npm run build`)
6. Ensure SSR compatibility (check for `typeof window !== "undefined"`)

### Adding TipTap Extensions
1. Install package: `npm install @tiptap/extension-name`
2. Import in Editor.tsx
3. Add to `useEditor` extensions array
4. Add toolbar button if needed
5. Style in globals.css if necessary

### Adding Code Languages
1. Import language from highlight.js
2. Register with lowlight instance
3. Add to CODE_LANGUAGES array
4. Update language dropdown

### Adding GitHub API Routes
1. Create route file in `/app/api/github/[endpoint]/route.ts`
2. Export POST function
3. Use `validateGitHubFields()` and `parseRepo()` from utils
4. Use Octokit for GitHub operations
5. Return consistent response format
6. Handle errors appropriately
7. Purge cache if modifying files

### Adding New API Endpoints
1. Use shared utilities from `app/utils/`
2. Follow existing API patterns
3. Add caching where appropriate
4. Add cache purge support
5. Use consistent error handling
6. Document query parameters and response format

## Environment Variables

Required:
- `GITHUB_TOKEN` - GitHub Personal Access Token
- `GITHUB_REPO` - Repository in format `owner/repo`

Optional:
- `GITHUB_BRANCH` - Branch name (default: `main`)
- `GITHUB_FOLDER` - Articles folder path
- `GITHUB_VIDEOS_FOLDER` - Videos folder path (default: `content/3.videos`)
- `GITHUB_AUTHOR_NAME` - Commit author name
- `GITHUB_AUTHOR_EMAIL` - Commit author email
- `OPENAI_API_KEY` - OpenAI API key
- `CONTENTSTACK_API_KEY` - Contentstack API key
- `CONTENTSTACK_MANAGEMENT_TOKEN` - Contentstack management token
- `CONTENTSTACK_REGION` - Contentstack region (`eu`, `us`, etc.)
- `CLOUDINARY_CLOUD_NAME` - Cloudinary cloud name
- `CLOUDINARY_API_KEY` - Cloudinary API key
- `CLOUDINARY_API_SECRET` - Cloudinary API secret
